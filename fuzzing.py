import json
import time
import requests
import logging
from typing import Dict, List
from datetime import datetime
import os

class GraphQLFuzzer:
    def __init__(self, endpoint_url: str, rate_limit: float = 1.0, headers: Dict = None):
        """
        Args:
            endpoint_url (str): The GraphQL endpoint
            rate_limit (float): Minimum time between requests in seconds
            headers (Dict): Optional headers for GraphQL requests
        """
        self.endpoint_url = endpoint_url
        self.rate_limit = rate_limit
        self.last_request_time = 0
        self.headers = headers or {
            'Content-Type': 'application/json',
        }
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def load_queries(self, file_path: str) -> Dict:
        """Load GraphQL queries from JSON file generated by Llama"""
        try:
            if not os.path.isfile(file_path):
                raise FileNotFoundError(f"Query file not found: {file_path}")

            with open(file_path, 'r') as f:
                data = json.load(f)
                queries = data.get("queries", [])
            self.logger.info(f"Loaded queries from {file_path}")
            return queries
        except json.JSONDecodeError:
            self.logger.error(f"Failed to parse JSON from {file_path}")
            raise
        except Exception as e:
            self.logger.error(f"Error loading queries: {str(e)}")
            raise

    def send_graphql_request(self, query: Dict) -> Dict:
        """
        Send a single GraphQL request with rate limiting
        We never send requests faster than our rate limit
        We only wait as long as necessary to meet the rate limit
        """
        # Implement rate limiting
        current_time = time.time()
        time_since_last_request = current_time - self.last_request_time
        if time_since_last_request < self.rate_limit:
            time.sleep(self.rate_limit - time_since_last_request)

        #TODO: need to change the payload later
        try:
            payload = {
                "query": query["query"],
            }

            self.logger.info(f"Sending GraphQL query: {query.get('name', 'Unnamed query')}")
            self.logger.debug(f"Full query: {json.dumps(payload)[:200]}...")

            response = requests.post(
                self.endpoint_url,
                json=payload,
                headers=self.headers
            )
            self.last_request_time = time.time()

            try:
                response_data = response.json()
            except json.JSONDecodeError:
                response_data = {
                    "error": "Invalid JSON response",
                    "raw_response": response.text
                }
            return {
                "status_code": response.status_code,
                "response": response_data
            }

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Request failed: {str(e)}")
            return {
                "error": str(e)
            }


    #TODO: run testing
    #TODO: run result

def main():
    fuzzer = GraphQLFuzzer(
        endpoint_url="https://rickandmortyapi.com/graphql",
        rate_limit=1.0,
        headers={
            'Content-Type': 'application/json',
        }
    )
    # Load and execute queries
    queries = fuzzer.load_queries("llama_query/rick_query.json")
    print(queries)

    # run test
    # results
    # Save results


if __name__ == "__main__":
    main()